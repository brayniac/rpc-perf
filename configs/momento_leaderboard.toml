# An example configuration for benchmarking Momento (https://www.gomomento.com)
# and demonstrating the use of the preview functionality for collections. Each
# command family is using its own keyspace and covers key-value, hash, list,
# set, and sorted set.
#
# Expiration: unless otherwise specified, the default TTL of 15 minutes will be
# used. Commands which operate on collections will not refresh the TTL for the
# collection.

[general]
# specify the protocol to be used
protocol = "momento"
# the interval for stats integration and reporting
interval = 1
# the number of intervals to run the test for
duration = 30
# run the admin thread with a HTTP listener at the address provided, this allows
# stats exposition via HTTP
admin = "127.0.0.1:9090"
# optionally, set an initial seed for the PRNGs used to generate the workload.
# The default is to intialize from the OS entropy pool.
initial_seed = "0"

#[metrics]
# output file for detailed stats during the run
#output = "rpcperf.parquet"
# format of the output file (possible values are json, msgpack, parquet)
#format = "parquet"
# optionally specify batch size for parquet row groups
# only valid for parquet output
#batch_size = 100_000
# optionally specify histogram type (can be standard (default) or sparse)
# only valid for parquet output
#histogram = "sparse"
# optionally, specify the sampling interval for metrics. Input is a string
# with the unit attached; for example "100ms" or "1s". Defaults to 1s.
# interval = "1s"

[debug]
# choose from: error, warn, info, debug, trace
log_level = "info"
# optionally, log to the file below instead of standard out
# log_file = "rpc-perf.log"
# backup file name for use with log rotation
log_backup = "rpc-perf.log.old"
# trigger log rotation when the file grows beyond this size (in bytes). Set this
# option to '0' to disable log rotation.
log_max_size = 1073741824

[target]
# we don't need to specify an endpoint
endpoints = []
# leaderboards exist within a cache, so we specify that here
cache_name = "default-cache"

[leaderboard_client]
# number of threads used to drive client requests
threads = 4
# number of gRPC clients to initialize, each maintains at least one TCP stream
poolsize = 4
# an upper limit on the number of concurrent requests per gRPC client
concurrency = 128
# the connect timeout in milliseconds
connect_timeout = 10000
# set the timeout in milliseconds
request_timeout = 1000

[workload]
# the number of threads that will be used to generate the workload
threads = 1

[workload.ratelimit]
# set a global ratelimit for the workload
start = 50

# An example keyspace showcasing the use of the `key-value` family of commands.
#
# Note that we can constrain the number of keys in the keyspace and specify that
# the generated values are random bytes with 128B values.
[[workload.leaderboards]]
# sets the relative weight of this keyspace: defaults to 1
weight = 1

# sets the number of keys that will be generated
leaderboards = 100

# optionally, we can set the length of the leaderboard name
name_length = 32

# limit the number of ids that will be used
ids = 1000

# controls what commands will be used in this keyspace
commands = [
	# delete a leaderboard
	# { verb = "delete", weight = 1 },

	# select the first N elements by rank by specifying a limit and ordering
	{ verb = "get_by_rank", limit = 10, order = "descending", weight = 1 },

	# select by score without a score filter and using offset and limit for pagination
	{ verb = "get_by_score", offset = 0, limit = 0, order = "descending", weight = 1 },

	# get the rank for some specific ids within a leaderboard
	{ verb = "get_rank", ids = 8, order = "descending", weight = 1 },

	# get the number of elements in a leaderboard
	{ verb = "length", weight = 1 },

	# remove some number of elements from a leaderboard
	{ verb = "remove", elements = 8, weight = 1 },

	# update/insert the scores for some number of ids within a leaderboard
	{ verb = "upsert", elements = 8, weight = 1 },
]
